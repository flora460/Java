ğŸ“Œ Fiche RÃ©sumÃ© : Collections en Java
1ï¸âƒ£ Introduction aux Collections
Les Collections en Java sont des structures permettant de gÃ©rer efficacement des ensembles de donnÃ©es. Elles font partie du framework Java Collections (JCF) et remplacent les tableaux classiques par des structures plus flexibles.

Principales interfaces des Collections :
List â†’ Collection ordonnÃ©e avec accÃ¨s indexÃ© (ArrayList, LinkedList).
Set â†’ Collection sans doublons (HashSet, TreeSet, LinkedHashSet).
Queue â†’ File dâ€™attente avec gestion FIFO (LinkedList, PriorityQueue).
Deque â†’ File dâ€™attente double entrÃ©e (ArrayDeque, LinkedList).
Map â†’ Association clÃ©/valeur (HashMap, TreeMap, LinkedHashMap).
2ï¸âƒ£ List : Stockage ordonnÃ© et indexÃ©
Une List est une collection ordonnÃ©e, oÃ¹ l'on peut accÃ©der aux Ã©lÃ©ments via un index.

ImplÃ©mentations principales :
ArrayList â†’ BasÃ© sur un tableau dynamique, rapide en accÃ¨s direct mais lent en insertion/suppression.
LinkedList â†’ BasÃ© sur une liste chaÃ®nÃ©e, rapide en modification mais plus lent en accÃ¨s direct.
MÃ©thodes clÃ©s :
add(element), add(index, element) â†’ Ajoute un Ã©lÃ©ment.
get(index) â†’ RÃ©cupÃ¨re un Ã©lÃ©ment.
remove(index), remove(object) â†’ Supprime un Ã©lÃ©ment.
indexOf(object), contains(object) â†’ Recherche un Ã©lÃ©ment.
3ï¸âƒ£ Set : Collection sans doublons
Un Set est une collection non ordonnÃ©e qui nâ€™accepte pas les doublons.

ImplÃ©mentations principales :
HashSet â†’ Utilise une table de hachage (rapide, ordre non garanti).
LinkedHashSet â†’ Conserve lâ€™ordre dâ€™insertion.
TreeSet â†’ Trie les Ã©lÃ©ments de faÃ§on naturelle ou avec un Comparator.
MÃ©thodes clÃ©s :
add(element), remove(element) â†’ Ajoute/supprime un Ã©lÃ©ment.
contains(element) â†’ VÃ©rifie la prÃ©sence dâ€™un Ã©lÃ©ment.
size() â†’ Retourne la taille du Set.
4ï¸âƒ£ Map : Association clÃ©/valeur
Une Map est une collection qui stocke des paires clÃ©/valeur.

ImplÃ©mentations principales :
HashMap â†’ Rapide mais ordre non garanti.
LinkedHashMap â†’ Conserve lâ€™ordre dâ€™insertion.
TreeMap â†’ Trie les clÃ©s automatiquement.
MÃ©thodes clÃ©s :
put(key, value), get(key) â†’ Ajoute/rÃ©cupÃ¨re une valeur.
remove(key) â†’ Supprime une paire clÃ©/valeur.
containsKey(key), containsValue(value) â†’ VÃ©rifie la prÃ©sence dâ€™un Ã©lÃ©ment.
keySet(), values(), entrySet() â†’ RÃ©cupÃ¨re les clÃ©s, valeurs ou entrÃ©es.
5ï¸âƒ£ Queue : Gestion FIFO (First In, First Out)
Une Queue est une file dâ€™attente oÃ¹ les Ã©lÃ©ments sont traitÃ©s dans lâ€™ordre dâ€™arrivÃ©e.

ImplÃ©mentations principales :
LinkedList â†’ ImplÃ©mente Queue avec une liste chaÃ®nÃ©e.
PriorityQueue â†’ Trie les Ã©lÃ©ments selon leur prioritÃ©.
MÃ©thodes clÃ©s :
offer(element), add(element) â†’ Ajoute un Ã©lÃ©ment.
poll() â†’ RÃ©cupÃ¨re et supprime le premier Ã©lÃ©ment.
peek() â†’ RÃ©cupÃ¨re le premier Ã©lÃ©ment sans le supprimer.
6ï¸âƒ£ Deque : File dâ€™attente double entrÃ©e
Une Deque (double-ended queue) permet dâ€™ajouter et supprimer des Ã©lÃ©ments Ã  lâ€™avant et Ã  lâ€™arriÃ¨re.

ImplÃ©mentations principales :
LinkedList â†’ Moins optimisÃ© mais plus flexible.
ArrayDeque â†’ Meilleure performance pour lâ€™ajout/suppression aux extrÃ©mitÃ©s.
MÃ©thodes clÃ©s :
addFirst(element), addLast(element) â†’ Ajout en dÃ©but/fin.
removeFirst(), removeLast() â†’ Suppression en dÃ©but/fin.
getFirst(), getLast() â†’ RÃ©cupÃ©ration en dÃ©but/fin.
Parcourir une Deque en sens inverse :
java
Copier
Modifier
Deque<String> deque = new ArrayDeque<>();
deque.addLast("Mike");
deque.addLast("Jack");
deque.addLast("John");

Iterator<String> iterator = deque.descendingIterator();
while(iterator.hasNext()) {
  System.out.println(iterator.next());
}
// Output : "John", "Jack", "Mike"
âœ… Conclusion
List : Collection ordonnÃ©e et indexÃ©e.
Set : Collection sans doublons.
Map : Association clÃ©/valeur.
Queue : Gestion FIFO (Premier entrÃ©, premier sorti).
Deque : Gestion double entrÃ©e (ajout et suppression en dÃ©but/fin).
ğŸ’¡ Astuce : Choisir lâ€™implÃ©mentation selon le besoin (performance, tri, insertion rapide, etc.).

